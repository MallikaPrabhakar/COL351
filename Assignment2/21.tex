\begin{solution}{2.1}
    \begin{question}
        Given a set of C courses, devise the most efficient algorithm to find out an order for taking the courses so that a student is able to take all the n courses with the prerequisite criteria being satisfied, if such an order exists. What is the time complexity of your algorithm?
    \end{question}
    \tcblower{}
    
    \begin{proof}[Solution]
        In this problem, an order of completing courses exists if there is no loop in the graph. A directed graph ($G$) is generated by setting all courses as vertices ($V$ or $C$) and the pre-requirements of a course as edges ($E$) which is directed from the pre-requisite course to the course which needs it as pre-requisite. We use topological sort for obtaining a solution and return an empty array if no order exists (i.e., there is a loop in the graph).
        \begin{algorithm}[H]
            \caption{The way in which courses can be completed}\label{alg:topo}
            \begin{algorithmic}
            \Procedure{Order}{$G$}
                \State{$adjList \gets generateAdjList(G)$} \Comment{Creates an adjacency list in $O(V+E)$ time}
                \State{$colour \gets new \ dictionary()$}
                \State{$colour[node] \gets 0$ for all nodes} \Comment{0 represents unvisited}
                \State{$tOrder \gets []$}
                \State{$valid \gets true$}
                \ForAll{node in $G$}
                    \If{$colour[node]=0$}   \Comment{node is unvisited}
                        \State{perform $DFS(node,adjList,colour,valid)$} \Comment{directly alters variables at source}
                    \EndIf{}
                \EndFor{}
                \If{$valid=true$}
                    \State{\Return{$reverse(tOrder)$}}\Comment{tOrder should be reversed}
                \Else{}
                \State{\Return{$[]$}}
                \EndIf{}
            \EndProcedure{}
            \end{algorithmic}
        \end{algorithm}
        
        \begin{algorithm}[H]
            \caption{DFS function}
            \begin{algorithmic}
            \Procedure{DFS}{$node,adjList,colour,valid$}
                \State{$colour[node]=1$}
                \ForAll{$neighbours$ in $adjList[node]$}
                    \If{$colour[neighbour]=0$} \Comment{neighbour is also unvisited}
                    \State{$DFS(neighbour,adjList,colour,valid)$}
                    \ElsIf{$colour[neighbour]=1$} \Comment{Implies cycle exists}
                    \State{$valid\gets false$}
                    \State{\Return{}}
                    \EndIf{}
                \EndFor{}
                \State{$color[node]\gets2$} \Comment{node is fully processed}
                \State{push $node$ in $tOrder$} \Comment{add node at the end}
            \EndProcedure{}
            \end{algorithmic}
        \end{algorithm}
        \begin{proof}[Proof of correctness]
            The requirement for a course is that its prerequisites must be completed before the course is taken. Let the ordered list of courses be given by $T$. Now, the requirement can be mathematically formulated as
            \begin{equation}\label{eq:prereq}
                \forall c_1, c_2\in C: prereq(c_1, c_2)\implies pos_T(c_1) < pos_T(c_2)
            \end{equation}
            Here $pos_T(c)$ gives the position of course $c$ in the list $T$. We know that a course $c_1$ is a prereq of course $c_2$ iff there is an edge $(c_1, c_2)$ in $G$, the graph we have formulated. Therefore, the Equation~\ref{eq:prereq} is equivalent to saying that:
            \begin{equation}\label{eq:topo}
                \forall c_1, c_2\in C: (c_1, c_2)\in E(G)\implies pos_T(c_1) < pos_T(c_2)
            \end{equation}
            This is exactly the condition for a topological sort on graph $G$. Therefore we compute the topological sort on $G$ using the DFS algorithm discussed in class. The only difference is that instead of computing the finish times and then sorting the vertices, we make the observation that the order of increasing finish times are equivalent to the order in which DFS returns from each vertex. Therefore we push vertices in this postorder fashion and then reverse the list obtained to
            generate the topological sorting on $G$.\\
            This completes the proof of correctness of our approach and Algorithm~\ref{alg:topo}
        \end{proof}
        \begin{proof}[Proof of termination]
            To check if the algorithm terminates, as for loop has finite number of steps, we need to check the termination of $DFS$ function. The $for$ loop in DFS terminates if-
            \begin{enumerate}
                \item There is a cycle
                \item All the $neighbours$ are processed
            \end{enumerate}
            Since the number of $neighbours$ are finite, Condition 2 also terminates after finite steps.
            Moreover, the number of times DFS function in the $Order$ function is called can not be larger than $|V|$. Hence the algorithm terminates.
        \end{proof}
        \begin{proof}[Time Complexity]
        Following are the methods to be considered for analysind time complexity-
            \begin{itemize}
                \item Time to make adjList: $O(V+E)$ (trivial)
                \item Time to make colour: $O(V)$ (trivial)
                \item Time taken by main $for$ loop of $Order$:
                $O(V+E)$ (since DFS)
            \end{itemize}
            Hence the overall time complexity of the $Order$ function becomes $O(V+E)$
        \end{proof}
        \begin{proof}[Space Complexity]
            Space complexity is determined by size of $adjList$ adjacency list and $colour$ array.
            Complexity=$O(V+E)+O(V)$=$O(V+E)$
        \end{proof} 
    \end{proof}
\end{solution}
