% TODO:
% no need to explain in detail about how the graph is taken as input - only mention that insertion and deletion from adj list can be done in O(1) using hashing, and O(log(n)) using a balanced-BST
% I know you just wrote a rough sketch abhi, but don't forget to modify algorithm to look more pseudocode-y (1b dekh lena for reference, or Navneel's directly)
%
% Structuring the solution post writing the algorithm:
% Termination -
% In each iteration of the loop except the last iteration, the number of vertices reduce by 1 and hence the loop will run for atmost n+1 iterations
% Correctness -
% 1. removing nodes with degree < k is necessary
% 2. removing nodes with degree > n - k - 1 is necessary
% 3. after no more such removals possible, show remaining graph satisfies the constraints
% PS: it might look noice if we replace 5 by k everywhere, gives vibes that we solved a more generic problem and we can state this at the start
%yayyyy i totally agree with all the points mentioned @sayam
\begin{solution}{Question 3.a}
    \begin{question}[]
        Present an efficient algorithm which outputs best choice of party invitees as per following specifications:\\
        1. Input: list of n people and list of pairs who know each other (undirectional)\\
        2. Every person invited should have atleast 5 people they know and 5 people they don't know at the party
    \end{question}
    \tcblower{}
    \begin{proof}[Solution]
        The main idea here is to obtain an adjacency list from the input and parse it. After creating an adjacency list, we keep on iterating over it until no new changes are being made. In every iteration of going over the adjacency list, we go over each vertex and see if the number of neighbours is less than 5 or greater than n-5-1. If either is the case, we "delete" the vertex and all of its edges else, continue. The algorithm is as follows: %remodel because heap? @TODO: yes
        
        add description of adj, people as well
        
        \begin{algorithm}[H]
            \caption{Generate list of invitees for 3.a}
            \begin{algorithmic}[1]
                \Procedure{Invite}{$G$}
                    \State{initialise $adj$} \Comment{empty hashmap of balanced BSTs created for adjacency list}
                    \State{initialise $people$} \Comment{empty balanced BST of degree,vertex pairs}
                    \ForAll{edge e $\{ u, v \}$ in E(G)} \Comment{sets adj}
                        \State{add v to adj[u]}
                        \State{add u to adj[v]}
                    \EndFor{}
                    \ForAll{vertex v in V(G)} \Comment{sets people}
                        \State{add (degree(v), v) to people}
                    \EndFor{}
                    
                    \State{$done\gets false$} \Comment{denotes if $people$ is changing}
                    \While{not $done$}
                        \State{$done\gets$ true}
                        \If{$people$ is empty}
                            \State{\textbf{break}}
                        \EndIf{}
                        \State{$i\gets start(people)$}
                        \If{$degree(i) < k$}
                            \State{$done\gets false$}
                            \State{$deletePerson(vertex(i))$}
                        \EndIf{}
                        \State{$i\gets end(people)$}
                        \If{$size(people)-degree(i)-1 < k$}
                            \State{$done\gets false$}
                            \State{$deletePerson(vertex(i))$}
                        \EndIf{}
                    \EndWhile{}
                    \State{$invitees\gets[]$}
                    \ForAll{person in people}
                        \State{$invitees.append(person.second)$}
                    \EndFor{}
                    \State{\Return{invitees}}
                \EndProcedure{}
            \end{algorithmic}
        \end{algorithm}
        
        The procedure $deletePerson$ takes the vertex $u$ into consideration for removal as a parameter and updates the adjacency list $adj$ and $people$. Idea behind the algorithm is to look at all the neighbours of v and remove the edge $\{u,v\}$ from $adj$ and update degree of $v$ in $people$. If degree of $v$ becomes zero, don't add it again.\\
        Since people is a balanced BST, time complexity of removal and insertion is $O(log|V|)$ because $size(people)=|V|$. Also, adjacency list can be implemented as a hashmap of balanced BSTs, so locationg a vertex $v$ takes $O(1)$ time and removing a vertex $u$ from the hashmap[v] takes $O(log \ degree)$
        \\
        Total time complexity of the procedure $deletePerson$ hence becomes
        \begin{equation}
            \begin{split}
                O(degree(u))\times O(\log|V| +\log(degree(v)))+O(\log|V| )
                &=O(degree(u)\times \log|V|)
            \end{split}
        \end{equation}

        \begin{algorithm}[H]
            \caption{sub-algorithm for $deletePerson$}
            \begin{algorithmic}[1]
                \Procedure{deletePerson}{$u$}
                \ForAll{vertex $v$ in neighbours of $u$}
                \State{remove $\{degree(v), v\}$ from $people$}
                \State{remove $u$ from $adj(v)$}
                \If{$degree(v)\neq 0$}
                    \State{insert $\{degree(v), v\}$ into $people$}
                \EndIf{}
                \EndFor
                \State{remove $\{degree(u), u\}$ from $people$}
                \State{\Return{}}
                \EndProcedure{}
            \end{algorithmic}
        \end{algorithm}
        % @TODO: the following
        \subsection*{Initialisation}
        \subsection*{Maintenance}
        \subsection*{Termination}
        \subsection*{Validate best solution}
        
    \end{proof}
\end{solution}

